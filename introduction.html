<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="assets/style.css?t=d358ee59">
    <link rel="stylesheet" href="docs.css?t=4f015f21">
    <script src="assets/script.js?t=42463e55"></script>
    <title>Introduction - Telegraf</title>
    <meta name="viewport" content="width=device-width">
  </head>
  <body class="-menu-visible">
    <div class="doc-layout">
      <div class="toggle menu-toggle js-menu-toggle"></div>
      <div class="menu toc-menu">
        <li class="menu-item -level-0 -parent">
          <ul class="submenu">
            <li class="menu-item -level-1 -parent"><a class="link title  link-index" href="index.html">Telegraf</a>
              <ul class="submenu">
                <li class="menu-item -level-2"><a class="link title -active link-introduction" href="introduction.html">Introduction</a>
                  <ul class="headings heading-list">
                    <li class="heading-item -depth-2"><a class="hlink link-application" href="#application">Application</a>
                    </li>
                    <li class="heading-item -depth-2"><a class="hlink link-middleware" href="#middleware">Middleware</a>
                    </li>
                    <li class="heading-item -depth-2"><a class="hlink link-error-handling" href="#error-handling">Error handling</a>
                    </li>
                    <li class="heading-item -depth-2"><a class="hlink link-context" href="#context">Context</a>
                    </li>
                    <li class="heading-item -depth-2"><a class="hlink link-state" href="#state">State</a>
                    </li>
                    <li class="heading-item -depth-2"><a class="hlink link-session" href="#session">Session</a>
                    </li>
                    <li class="heading-item -depth-2"><a class="hlink link-update-types" href="#update-types">Update types</a>
                    </li>
                    <li class="heading-item -depth-2"><a class="hlink link-webhooks" href="#webhooks">Webhooks</a>
                    </li>
                  </ul>
                </li>
                <li class="menu-item -level-2"><a class="link title  link-context" href="context.html">Context</a>
                </li>
                <li class="menu-item -level-2"><a class="link title  link-advanced" href="advanced.html">Advanced usage</a>
                </li>
              </ul>
            </li>
            <li class="menu-item -level-1 -parent"><span class="title">API Reference</span>
              <ul class="submenu">
                <li class="menu-item -level-2"><a class="link title  link-telegraf" href="telegraf.html">Telegraf</a>
                </li>
                <li class="menu-item -level-2"><a class="link title  link-telegram" href="telegram.html">Telegram</a>
                </li>
                <li class="menu-item -level-2"><a class="link title  link-extra" href="extra.html">Reply markup</a>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </div>
      <div class="body page-introduction">
        <div class="header-nav">
          <div class="right"><a class="iconlink" href="https://github.com/telegraf/telegraf" data-title="telegraf/telegraf">
              <!-- span.title Open in GitHub--><span class="icon -github"></span></a>
          </div>
        </div>
        <div class="markdown-body"><h1 id="introduction">Introduction</h1>
<h2 id="application">Application</h2>
<p>A Telegraf application is an object containing an array of middlewares which are composed
and executed in a stack-like manner upon request. Is similar to many other middleware systems
that you may have encountered such as Koa, Ruby&apos;s Rack, Connect.</p>
<h2 id="middleware">Middleware</h2>
<p>Middleware is an essential part of any modern framework.
It allows you to modify requests and responses as they pass between the Telegram and your bot.</p>
<p>You can imagine middleware as a chain of logic connection your bot to the Telegram request.</p>
<p>Middleware normally takes two parameters (ctx, next), <code>ctx</code> is the context for one Telegram message,
<code>next</code> is a function that is invoked to execute the downstream middleware.
It returns a Promise with a then function for running code after completion.</p>
<pre><code class="lang-js"><span class="pl-k">const</span> app = <span class="pl-k">new</span> Telegraf(process.env.BOT_TOKEN)

app.use(<span class="hljs-function">(<span class="hljs-params">ctx, next</span>) =&gt;</span> {
  <span class="pl-k">const</span> start = <span class="pl-k">new</span> <span class="pl-c1">Date</span>()
  <span class="pl-k">return</span> next().then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="pl-k">const</span> ms = <span class="pl-k">new</span> <span class="pl-c1">Date</span>() - start
    <span class="pl-c1">console</span>.log(<span class="pl-s">&apos;Response time %sms&apos;</span>, ms)
  })
})

app.on(<span class="pl-s">&apos;text&apos;</span>, (ctx) =&gt; ctx.reply(<span class="pl-s">&apos;Hello World&apos;</span>))
</code></pre>
<h4 id="cascading-with-async-functions">Cascading with async functions</h4>
<p>You might need Babel(or <code>node &gt;=v.7.x</code> with harmony flags) for running following example.</p>
<pre><code class="lang-js">app.use(<span class="pl-k">async</span> (ctx, next) =&gt; {
  <span class="pl-k">const</span> start = <span class="pl-k">new</span> <span class="pl-c1">Date</span>()
  <span class="pl-k">await</span> next()
  <span class="pl-k">const</span> ms = <span class="pl-k">new</span> <span class="pl-c1">Date</span>() - start
  <span class="pl-c1">console</span>.log(<span class="pl-s">&apos;Response time %sms&apos;</span>, ms)
})
</code></pre>
<h4 id="known-middleware">Known middleware</h4>
<ul>
<li><a href="https://github.com/telegraf/telegraf-i18n">Internationalization</a></li>
<li><a href="https://github.com/telegraf/telegraf-session-redis">Redis powered session</a></li>
<li><a href="https://github.com/RealSpeaker/telegraf-session-local">Local powered session (via lowdb)</a> - Supports in-memory/(a)sync files/... &amp; JSON/YAML/XML/...</li>
<li><a href="https://github.com/telegraf/telegraf-flow">Stateful chatbots engine</a></li>
<li><a href="https://github.com/telegraf/telegraf-ratelimit">Rate-limiting</a></li>
<li><a href="https://github.com/telegraf/telegraf-wit">Natural language processing via wit.ai</a></li>
<li><a href="https://github.com/telegraf/telegraf-recast">Natural language processing via recast.ai</a></li>
<li><a href="https://github.com/telegraf/telegraf-experiments">Multivariate and A/B testing</a></li>
<li><a href="https://github.com/telegraf/telegraf-mixpanel">Powerfull bot stats via Mixpanel</a></li>
<li><a href="https://github.com/telegraf/telegraf-statsd">statsd integration</a></li>
<li><a href="https://www.npmjs.com/search?q=telegraf-">and more...</a></li>
</ul>
<h2 id="error-handling">Error handling</h2>
<p>By default Telegraf will print all errors to stderr and rethrow error.</p>
<p>To perform custom error-handling logic use following snippet:</p>
<pre><code class="lang-js"><span class="pl-k">const</span> app = <span class="pl-k">new</span> Telegraf(process.env.BOT_TOKEN)

app.catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
  <span class="pl-c1">console</span>.log(<span class="pl-s">&apos;Ooops&apos;</span>, err)
})
</code></pre>
<h2 id="context">Context</h2>
<p>A Telegraf context encapsulates telegram update.</p>
<pre><code class="lang-js">app.on(<span class="pl-s">&apos;sticker&apos;</span>, (ctx) =&gt; { 
  <span class="pl-c1">console</span>.log(ctx.message.sticker)
  <span class="pl-k">return</span> ctx.reply(<span class="pl-s">&apos;Hey there!&apos;</span>)
})
</code></pre>
<p><a href="context.html">Context documentation</a></p>
<h2 id="state">State</h2>
<p>The recommended namespace to share information between middlewares.</p>
<pre><code class="lang-js"><span class="pl-k">const</span> app = <span class="pl-k">new</span> Telegraf(process.env.BOT_TOKEN)

<span class="pl-c">// Auth middleware</span>
app.use(<span class="hljs-function">(<span class="hljs-params">ctx, next</span>) =&gt;</span> {
  ctx.state.role = getUserRole(ctx.message) 
  <span class="pl-k">return</span> next()
})

app.on(<span class="pl-s">&apos;text&apos;</span>, (ctx) =&gt; {
  <span class="pl-k">return</span> ctx.reply(<span class="pl-s">`Hello <span class="hljs-subst">${ctx.state.role}</span>`</span>)
})
</code></pre>
<h2 id="session">Session</h2>
<pre><code class="lang-js"><span class="pl-k">const</span> app = <span class="pl-k">new</span> Telegraf(process.env.BOT_TOKEN)

app.use(Telegraf.memorySession())

app.on(<span class="pl-s">&apos;text&apos;</span>, (ctx) =&gt; {
  ctx.session.counter = ctx.session.counter || <span class="hljs-number">0</span>
  ctx.session.counter++
  <span class="pl-k">return</span> ctx.reply(<span class="pl-s">`Message counter:<span class="hljs-subst">${ctx.session.counter}</span>`</span>)
})
</code></pre>
<p><strong>Note: For persistent sessions you might use any of <a href="https://www.npmjs.com/search?q=telegraf-session"><code>telegraf-session-*</code></a> middleware.</strong></p>
<h2 id="update-types">Update types</h2>
<p>Supported update types:</p>
<ul>
<li><code>message</code></li>
<li><code>edited_message</code></li>
<li><code>callback_query</code></li>
<li><code>inline_query</code></li>
<li><code>shipping_query</code></li>
<li><code>pre_checkout_query</code></li>
<li><code>chosen_inline_result</code></li>
<li><code>channel_post</code></li>
<li><code>edited_channel_post</code></li>
</ul>
<p>Available update sub-types:
<code>text</code>, <code>audio</code>, <code>document</code>, <code>photo</code>, <code>sticker</code>, <code>video</code>, <code>voice</code>, <code>contact</code>,
<code>location</code>, <code>venue</code>, <code>new_chat_members</code>, <code>left_chat_member</code>, <code>new_chat_title</code>,
<code>new_chat_photo</code>, <code>delete_chat_photo</code>, <code>group_chat_created</code>, <code>migrate_to_chat_id</code>,
<code>supergroup_chat_created</code>, <code>channel_chat_created</code>, <code>migrate_from_chat_id</code>,
<code>pinned_message</code>, <code>game</code>, <code>video_note</code>, <code>invoice</code>, <code>successful_payment</code>.</p>
<pre><code class="lang-js">
<span class="pl-c">// Handle message update</span>
telegraf.on(<span class="pl-s">&apos;message&apos;</span>, (ctx) =&gt;  {
  <span class="pl-k">return</span> ctx.reply(<span class="pl-s">&apos;Hey there!&apos;</span>)
})

<span class="pl-c">// Handle sticker or photo update</span>
telegraf.on([<span class="pl-s">&apos;sticker&apos;</span>, <span class="pl-s">&apos;photo&apos;</span>], (ctx) =&gt;  {
  <span class="pl-c1">console</span>.log(ctx.message)
  <span class="pl-k">return</span> ctx.reply(<span class="pl-s">&apos;Cool!&apos;</span>)
})

</code></pre>
<p><sub><a href="https://core.telegram.org/bots/api#message">Related Telegram api docs</a></sub></p>
<h2 id="webhooks">Webhooks</h2>
<pre><code class="lang-js">
<span class="pl-k">const</span> app = <span class="pl-k">new</span> Telegraf(process.env.BOT_TOKEN)

<span class="pl-c">// TLS options</span>
<span class="pl-k">const</span> tlsOptions = {
  <span class="hljs-attr">key</span>:  fs.readFileSync(<span class="pl-s">&apos;server-key.pem&apos;</span>),
  <span class="hljs-attr">cert</span>: fs.readFileSync(<span class="pl-s">&apos;server-cert.pem&apos;</span>),
  <span class="hljs-attr">ca</span>: [ 
    <span class="pl-c">// This is necessary only if the client uses the self-signed certificate.</span>
    fs.readFileSync(<span class="pl-s">&apos;client-cert.pem&apos;</span>) 
  ]
}

<span class="pl-c">// Set telegram webhook</span>
app.telegram.setWebhook(<span class="pl-s">&apos;https://server.tld:8443/secret-path&apos;</span>, {
  <span class="hljs-attr">source</span>: fs.readFileSync(<span class="pl-s">&apos;server-cert.pem&apos;</span>)
})

<span class="pl-c">// Start https webhook</span>
app.startWebhook(<span class="pl-s">&apos;/secret-path&apos;</span>, tlsOptions, <span class="hljs-number">8443</span>)


<span class="pl-c">// Http webhook, for nginx/heroku users.</span>
app.startWebhook(<span class="pl-s">&apos;/secret-path&apos;</span>, <span class="pl-c1">null</span>, <span class="hljs-number">5000</span>)

</code></pre>
<p>Use webhookCallback() if you want to attach telegraf to existing http server</p>
<pre><code class="lang-js">
<span class="pl-c1">require</span>(<span class="pl-s">&apos;http&apos;</span>)
  .createServer(app.webhookCallback(<span class="pl-s">&apos;/secret-path&apos;</span>))
  .listen(<span class="hljs-number">3000</span>)

<span class="pl-c1">require</span>(<span class="pl-s">&apos;https&apos;</span>)
  .createServer(tlsOptions, app.webhookCallback(<span class="pl-s">&apos;/secret-path&apos;</span>))
  .listen(<span class="hljs-number">8443</span>)

</code></pre>
<p>Connect/Express.js integration</p>
<pre><code class="lang-js"><span class="pl-k">const</span> express = <span class="pl-c1">require</span>(<span class="pl-s">&apos;express&apos;</span>)
<span class="pl-k">const</span> expressApp = express()

expressApp.use(app.webhookCallback(<span class="pl-s">&apos;/secret-path&apos;</span>))

expressApp.get(<span class="pl-s">&apos;/&apos;</span>, (req, res) =&gt; {
  res.send(<span class="pl-s">&apos;Hello World!&apos;</span>)
})

expressApp.listen(<span class="hljs-number">3000</span>, () =&gt; {
  <span class="pl-c1">console</span>.log(<span class="pl-s">&apos;Example app listening on port 3000!&apos;</span>)
})

</code></pre>

        </div>
        <div class="footer-nav">
          <div class="left"><a href="index.html"><span class="title">Telegraf</span></a></div>
          <div class="right"><a href="context.html"><span class="label">Next: </span><span class="title">Context</span></a></div>
        </div>
      </div>
    </div>
  </body>
</html>