{
  "name": "Telegraf",
  "tagline": "ðŸ“¢ Telegram bot framework for Node.js",
  "body": "## Features\r\n\r\n- Full [Telegram Bot API 2.1](https://core.telegram.org/bots/api) support\r\n- [Inline mode](https://core.telegram.org/bots/api#inline-mode)\r\n- Incredibly fast\r\n- Easy to extend\r\n- [Middlewares, middlewares everywhere](#middlewares)\r\n- http/https/Connect/express.js webhooks\r\n- Reply via webhook\r\n\r\n## Middlewares\r\n\r\n- [Internationalization](https://github.com/telegraf/telegraf-i18n)\r\n- [Redis powered session](https://github.com/telegraf/telegraf-session-redis)\r\n- [Rate-limiting](https://github.com/telegraf/telegraf-ratelimit)\r\n- [Micro dialog engine](https://github.com/telegraf/telegraf-quiz)\r\n- [Chat flow engine](https://github.com/telegraf/telegraf-flow)\r\n- [Mixpanel integration](https://github.com/telegraf/telegraf-mixpanel)\r\n- [Multivariate and A/B testing](https://github.com/telegraf/telegraf-experiments)\r\n- [statsd integration](https://github.com/telegraf/telegraf-statsd)\r\n- [and more...](https://www.npmjs.com/search?q=telegraf-)\r\n\r\n## Installation\r\n\r\n```js\r\n$ npm install telegraf\r\n```\r\n\r\n## Examples\r\n  \r\n```js\r\nconst Telegraf = require('telegraf')\r\n\r\nconst app = new Telegraf(process.env.BOT_TOKEN)\r\napp.on('message', (ctx) => ctx.replyWithMarkdown('*42*'))\r\n\r\napp.startPolling()\r\n```\r\n\r\nThere are some other [examples](/examples).\r\n\r\n## API\r\n\r\n[Telegraf API reference](https://github.com/telegraf/telegraf/blob/master/docs/api.md)\r\n\r\n### Application\r\n\r\nA Telegraf application is an object containing an array of middlewares which are composed \r\nand executed in a stack-like manner upon request. Is similar to many other middleware systems \r\nthat you may have encountered such as Koa, Ruby's Rack, Connect.\r\n\r\n### Context\r\n\r\nA Telegraf Context encapsulates telegram message.\r\nContext is created per request and contains following props:\r\n\r\n```js\r\napp.use((ctx) => {\r\n  ctx.telegram             // Telegram instance\r\n  ctx.updateType           // Update type(message, inline_query, etc.)\r\n  [ctx.updateSubType]      // Update subtype(text, sticker, audio, etc.)\r\n  [ctx.message]            // Received message\r\n  [ctx.editedMessage]      // Edited message\r\n  [ctx.inlineQuery]        // Received inline query\r\n  [ctx.chosenInlineResult] // Received inline query result\r\n  [ctx.callbackQuery]      // Received callback query\r\n  [ctx.chat]               // Current chat info\r\n  [ctx.from]               // Sender info\r\n  [ctx.match]              // Regex match (available only for `hears` handler)\r\n})\r\n```\r\n[Context api docs](/api.md#context)\r\n\r\n### Cascading\r\n\r\nMiddleware normally takes two parameters (ctx, next), `ctx` is the context for one Telegram message,\r\n`next` is a function that is invoked to execute the downstream middleware. \r\nIt returns a Promise with a then function for running code after completion.\r\n\r\n```js\r\nconst app = new Telegraf(process.env.BOT_TOKEN)\r\n\r\n// Logger middleware\r\napp.use((ctx, next) => {\r\n  const start = new Date()\r\n  return next().then(() => {\r\n    const ms = new Date() - start\r\n    console.log('response time %sms', ms)\r\n  })\r\n})\r\n\r\napp.on('text', (ctx) => {\r\n  return ctx.reply('Hello World')\r\n})\r\n```\r\n\r\n### State\r\n\r\nThe recommended namespace to share information between middlewares.\r\n\r\n```js\r\nconst app = new Telegraf(process.env.BOT_TOKEN)\r\n\r\napp.use((ctx, next) => {\r\n  ctx.state.role = getUserRole(ctx.message) \r\n  return next()\r\n})\r\n\r\napp.on('text', (ctx) => {\r\n  return ctx.reply(`Hello ${ctx.state.role}`)\r\n})\r\n```\r\n\r\n### Session\r\n\r\n```js\r\nconst app = new Telegraf(process.env.BOT_TOKEN)\r\n\r\n// Session state will be lost on app restart\r\napp.use(Telegraf.memorySession())\r\n\r\napp.on('text', () => {\r\n  ctx.session.counter = ctx.session.counter || 0\r\n  ctx.session.counter++\r\n  return ctx.reply(`Message counter:${ctx.session.counter}`)\r\n})\r\n```\r\n\r\n**Important: For production environment use any of [`telegraf-session-*`](https://www.npmjs.com/search?q=telegraf-session) middleware.**\r\n\r\n### Telegram WebHook\r\n\r\n```js\r\n\r\nconst app = new Telegraf(process.env.BOT_TOKEN)\r\n\r\n// TLS options\r\nconst tlsOptions = {\r\n  key:  fs.readFileSync('server-key.pem'),\r\n  cert: fs.readFileSync('server-cert.pem'),\r\n  ca: [ \r\n    // This is necessary only if the client uses the self-signed certificate.\r\n    fs.readFileSync('client-cert.pem') \r\n  ]\r\n}\r\n\r\n// Set telegram webhook\r\napp.telegram.setWebHook('https://server.tld:8443/secret-path', {\r\n  content: 'server-cert.pem'\r\n})\r\n\r\n// Start https webhook\r\napp.startWebHook('/secret-path', tlsOptions, 8443)\r\n\r\n\r\n// Http webhook, for nginx/heroku users.\r\napp.startWebHook('/secret-path', null, 5000)\r\n\r\n\r\n// Use webHookCallback() if you want attach telegraf to existing http server\r\nrequire('http')\r\n  .createServer(app.webHookCallback('/secret-path'))\r\n  .listen(3000)\r\n\r\nrequire('https')\r\n  .createServer(tlsOptions, app.webHookCallback('/secret-path'))\r\n  .listen(8443)\r\n\r\n// Connect/Express.js integration\r\nconst express = require('express')\r\nconst expressApp = express()\r\n\r\nexpressApp.use(app.webHookCallback('/secret-path'))\r\n\r\nexpressApp.get('/', (req, res) => {\r\n  res.send('Hello World!')\r\n})\r\n\r\nexpressApp.listen(3000, () => {\r\n  console.log('Example app listening on port 3000!')\r\n})\r\n\r\n```\r\n\r\n### Error Handling\r\n\r\nBy default Telegraf will print all errors to stderr and rethrow error. \r\nTo perform custom error-handling logic you can set `onError` handler:\r\n\r\n```js\r\ntelegraf.onError = (err) => {\r\n  log.error('server error', err)\r\n  throw err\r\n}\r\n```\r\n\r\n## License\r\n\r\nThe MIT License (MIT)\r\n\r\nCopyright (c) 2016 Telegraf\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}